const fs = require("fs");
const path = require("path");
const mysql = require("mysql2/promise");
const { AuditLogEvent } = require("discord.js");
const config = require("../config.json");

const cacheFilePath = path.resolve(__dirname, "../cache/invites.json");

function loadInvitesCache() {
  if (fs.existsSync(cacheFilePath)) {
    try {
      const data = fs.readFileSync(cacheFilePath, "utf8");
      return JSON.parse(data);
    } catch (err) {
      console.error("Error reading invites cache file:", err);
      return {};
    }
  } else {
    return {};
  }
}

function saveInvitesCache(cache) {
  try {
    fs.writeFileSync(cacheFilePath, JSON.stringify(cache, null, 2), "utf8");
  } catch (err) {
    console.error("Error writing invites cache file:", err);
  }
}

module.exports = {
  name: "guildMemberAdd",
  async execute(member) {
    try {
      // First, load the file cache to get a snapshot of old invites.
      const fileCache = loadInvitesCache();
      const oldInvites = fileCache[member.guild.id]
        ? new Map(Object.entries(fileCache[member.guild.id]))
        : new Map();

      // (Optional) Also load into in-memory cache if not already present.
      if (!member.client.invites) member.client.invites = {};
      if (!member.client.invites[member.guild.id]) {
        member.client.invites[member.guild.id] = new Map(oldInvites);
      }

      // Now fetch fresh invite data from the server.
      const newInvites = await member.guild.invites.fetch();

      let usedInvite;
      if (oldInvites.size > 0) {
        usedInvite = newInvites.find(invite => {
          const cached = oldInvites.get(invite.code);
          return cached && invite.uses > cached.uses;
        });
      }

      // Fallback #1: If no change is detected and there's exactly one active invite, assume it's used.
      if (!usedInvite && newInvites.size === 1) {
        usedInvite = newInvites.first();
      }

      // Fallback #2: If still no used invite is detected, check audit logs (for temporary invites).
      if (!usedInvite) {
        const fetchedLogs = await member.guild.fetchAuditLogs({ 
          type: AuditLogEvent.InviteDelete, 
          limit: 1 
        });
        const deletionLog = fetchedLogs.entries.first();
        if (
          deletionLog &&
          deletionLog.target &&
          deletionLog.target.code &&
          deletionLog.target.inviter
        ) {
          const timeDiff = Date.now() - deletionLog.createdTimestamp;
          if (timeDiff < 10000) { // if deletion occurred within 10 seconds
            usedInvite = { 
              code: deletionLog.target.code, 
              inviter: deletionLog.target.inviter 
            };
          }
        }
      }

      // Debug: Log what invite was detected.
      if (usedInvite && usedInvite.inviter) {
        console.log(`Detected used invite: Code ${usedInvite.code} by ${usedInvite.inviter.tag}`);
      } else {
        console.log("No valid invite detected; falling back to 'unknown'.");
      }

      // Update both the in-memory cache and the file cache with fresh invite data.
      const newInvitesData = {};
      newInvites.each(invite => {
        newInvitesData[invite.code] = {
          uses: invite.uses,
          inviter: { id: invite.inviter.id, tag: invite.inviter.tag }
        };
      });
      // Update file cache
      fileCache[member.guild.id] = newInvitesData;
      saveInvitesCache(fileCache);
      // Also update in-memory cache with a fresh clone
      member.client.invites[member.guild.id] = new Map(newInvites);

      // Create a MySQL connection pool (consider sharing this pool globally in production)
      const db = mysql.createPool({
        host: config.mysql.host,
        user: config.mysql.user,
        password: config.mysql.password,
        database: config.mysql.database,
        waitForConnections: true,
        connectionLimit: 10,
        queueLimit: 0,
      });


      // Update the database based on the detected invite.
      if (usedInvite && usedInvite.inviter && !usedInvite.inviter.tag.startsWith("deleted_user_")) {
        await db.query(
          `INSERT INTO invite_logs (guild_id, inviter_id, inviter_tag, user_id, user_tag, invite_code, join_date)
           VALUES (?, ?, ?, ?, ?, ?, NOW())`,
          [
            member.guild.id,
            usedInvite.inviter.id,
            usedInvite.inviter.tag,
            member.id,
            member.user.tag,
            usedInvite.code,
          ]
        );
        await db.query(
          `INSERT INTO invite_stats (guild_id, inviter_id, inviter_tag, total_uses)
           VALUES (?, ?, ?, 1)
           ON DUPLICATE KEY UPDATE total_uses = total_uses + 1`,
          [
            member.guild.id,
            usedInvite.inviter.id,
            usedInvite.inviter.tag,
          ]
        );
        console.log(`Database updated for ${usedInvite.inviter.tag}.`);
      } else {
        await db.query(
          `INSERT INTO invite_logs (guild_id, inviter_id, inviter_tag, user_id, user_tag, invite_code, join_date)
           VALUES (?, ?, ?, ?, ?, ?, NOW())`,
          [
            member.guild.id,
            "unknown",
            "unknown",
            member.id,
            member.user.tag,
            "unknown"
          ]
        );
        console.log("Logged join as unknown in database.");
      }

      console.log(`Logged join for ${member.user.tag}`);
    } catch (error) {
      console.error(`Error logging join for ${member.user.tag}:`, error);
    }
  },
};
